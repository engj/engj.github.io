<!doctype html>
<html>
<head>
	<script src="//use.typekit.net/kjj1ade.js"></script>
	<script>try{Typekit.load();}catch(e){}</script>
	<script>
	window.onload = function(e) {
		scroll(0,0)
	}
	</script>
	
	<title>Self Balancing Bicycle</title>
	<link rel="stylesheet" href="main.css" />
</head>
<body>
	<div class="main">
		<header>
			<h1>Self Balancing Bicycle</h1>
		</header>
		<article>
			<h2>Motivation</h2>
			<p>Our group decided to build a scaled down model of a self balancing bicycle. We achieved balancing solely through front wheel steering without a gyroscopic or shifting mass for stabilization. We also implemented user-controlled heading on the bike to attain basic maneuverability.<p>
			<p>Our initial inspiration for this idea came from a <a href="https://www.youtube.com/watch?v=AvGUuuq7DOE">video</a> we saw of self balacing bicycle. We later learned that this robot had an inbuilt gyroscope for balancing and did not use steering exclusively for balance. Over the course of our exploration, we did not come across many demonstrations of balancing via steering only, other than one very inspiring non-robotic <a href="https://www.youtube.com/watch?v=Z38itkVtEqI">demonstration</a>. 
(In that video, due to the relative mass of the human pilot, we consider it unlikely that shifting mass has anything to do with the stability of the vehicle.)</p>
			<p>Thus, we decided to try and achieve the same.</p>
			<p>Our group was particularly interested in balancing through steering so that the system can potentially be scaled up to a real bike and used in some way to assist humans in the future.</p>
			<h2>System Design</h2>
			<p>As a team with prior experience developing code for microcontroller platforms such as the <a href="http://beagleboard.org/bone">BeagleBone</a> and the <a href="http://www.arduino.cc/">Arduino</a>, we did not think <a href="http://www.ni.com/labview/">LabView</a> on the <a href="http://www.ni.com/singleboard/">NI Single-Board RIO</a> would allow for the simplest and most efficient programming experience. We also found that the dimensions of the <a href="http://www.ni.com/singleboard/">NI Single-Board Rio</a> did not fit well with our project. In looking for alternatives we decided upon a combination of a <a href="http://beagleboard.org/bone">BeagleBone</a> and <a href="http://arduino.cc/">Arduino</a>, primarily because of accessibility as one of our members already had both of them. Additionally, one of the team members had already purchased an <a href="http://www.arduino.cc/">Arduino</a> compatible <a href="http://en.wikipedia.org/wiki/Inertial_measurement_unit">IMU</a> for another project. Using this <a href="http://en.wikipedia.org/wiki/Inertial_measurement_unit">IMU</a> with the preexisting <a href="http://www.varesano.net/projects/hardware/FreeIMU">Free<a href="http://en.wikipedia.org/wiki/Inertial_measurement_unit">IMU</a></a> library for the <a href="http://arduino.cc/">Arduino</a> would save us immeasurable time, as we would not have to figure out how to implement <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">SPI</a> or <a href="http://en.wikipedia.org/wiki/I%C2%B2C">I<sup>2</sup>C</a>, along with a complicated sensor fusion algorithm on the <a href="http://www.ni.com/singleboard/">NI Single-Board Rio</a>. With this in mind, we elected to use a host laptop running the controller <a href="http://en.wikipedia.org/wiki/Graphical_user_interface">GUI</a> to steer the bicycle, with a <a href="http://beagleboard.org/bone">BeagleBone</a>/<a href="http://arduino.cc">Arduino</a> combination on the bicycle itself for running the steering algorithm.</p>
			<p>Our communications scheme was as such: a laptop running the user interface software communicated with the <a href="http://beagleboard.org/bone">BeagleBone</a> over a WiFi network hosted by the laptop. The <a href="http://beagleboard.org/bone">BeagleBone</a> communicated with the <a href="http://arduino.cc/">Arduino</a> over serial <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a>. The computer sent a desired lean angle to the <a href="http://beagleboard.org/bone">BeagleBone</a>, which then forwarded this to the <a href="http://arduino.cc/">Arduino</a> for the controller. The <a href="http://www.arduino.cc/">Arduino</a> sent the <a href="http://beagleboard.org/bone">BeagleBone</a> the current lean angle and steering angle, which were forwarded to the computer to be displayed on a <a href="http://en.wikipedia.org/wiki/Graphical_user_interface">GUI</a>. The <a href="http://arduino.cc/">Arduino</a> took the desired lean angle and sensor data to control the steering angle.</p>
			<p>While abandoning <a href="http://www.ni.com/labview/">LabView</a> made writing the control loop, the user interface, and even the low level sensor interface code much easier, leaving the National Instruments' structured environment did introduce a number of challenges in return, some of which took considerable last minute effort to overcome. As we had prior experience using the <a href="http://beagleboard.org/bone">BeagleBone</a>'s <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a> to send data and using its <a href="http://en.wikipedia.org/wiki/General-purpose_input/output">GPIO</a> pins to control things, we had no second thoughts about choosing it to be the primary brains of the bicycle. However, a recent version update to its operating system by the kernel developers had completely restructured the way in which the input/output pins are enabled. This change is so new that there are very few people who fully understand how to use the new "device overlay" system to enable things like <a href="http://en.wikipedia.org/wiki/Pulse-width_modulation">PWM</a> channels and <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a>. This would have been no problem, as the older firmware images are still available on the internet, and we have experience with the old methods. However, as it would turn out though about ten re-flashes of the <a href="http://beagleboard.org/bone">BeagleBone</a>, none of the two WiFi cards we had on hand would work with the old versions of <a href="http://www.angstrom-distribution.org/">&Aring;ngstr&ouml;m</a> (the <a href="http://beagleboard.org/bone">BeagleBone</a> firmware). Despite these two cards working with our team members' Linux laptops, and despite the WiFi cards being recognized by their proper drivers on the <a href="http://beagleboard.org/bone">BeagleBone</a>, neither of them would work. It was only after a couple days of solid frantic reconfiguration did we scrounge up a third WiFi card. On a version of <a href="http://www.angstrom-distribution.org/">&Aring;ngstr&ouml;m</a> which had the old pin MUX configuration system, we eventually got the third WiFi card to work by copying over some firmware files (proprietary files that get loaded by the open source drivers into the WiFi cards) from a known working Linux laptop into the <a href="http://beagleboard.org/bone">BeagleBone</a> and restarting with our fingers crossed. This worked great, until the evening before our scheduled presentation, when the <a href="http://beagleboard.org/bone">BeagleBone</a> was inadvertently destroyed due to an electrical fault.</p>
			<p>After we took electrical precautions to ensure that would not be repeated, we borrowed another group member's <a href="http://beagleboard.org/bone">BeagleBone</a>. However, this new <a href="http://beagleboard.org/bone">BeagleBone</a> was not the original model, but the new and improved <a href="http://beagleboard.org/black">BeagleBone Black</a>, which is only capable of running the new version of <a href="http://www.angstrom-distribution.org/">&Aring;ngstr&ouml;m</a>, which enabled us to use any of the three WiFi cards (we went back to the first one, since it was a lot smaller than the other two we had). However, we were now without a way to enable the <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a> connection on the <a href="http://beagleboard.org/black">BeagleBone Black</a>, which was necessary for the <a href="http://beagleboard.org/black">BeagleBone Black</a> to tell the <a href="http://arduino.cc/">Arduino</a> what lean angle it should be at. After four frantic hours of googling, we finally found a blog post detailing the proper way to enable the <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a>. All in all, while abandoning <a href="http://www.ni.com/labview/">LabView</a> gave us a much more familiar environment in which to develop our code, we did put ourselves at the mercy of a number of bizarre unpredictable low level issues relating to the WiFi and <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a> connections. (Incidentally, the actual code required to have the <a href="http://beagleboard.org/black">BeagleBone Black</a> automatically connect to the laptop and automatically start listening for commands from the laptop was surprisingly easier than we had initially imagined. These issues would have been entirely avoided had we opted to use <a href="http://www.ni.com/labview/">LabView</a>'s pre built network variable synchronization.)</p>
			<figure>
				<img src="bike/system.png">
			</figure>
			<figure>
				<img src="bike/isometric.png">
			</figure>
			<figure>
				<img src="bike/side.png">
			</figure>
			<figure>
				<img src="bike/frame.png">
			</figure>
			<figure>
				<img src="bike/electronics.png">
			</figure>
			<h2>Controller</h2>
			<p>We decided to use <a href="http://en.wikipedia.org/wiki/Sliding_mode_control">sliding mode control</a> as the main control approach for stabilizing the bike. We originally created the controller in <a href="http://www.mathworks.com/products/matlab/">MATLAB</a>, and then simulated it using the plant model given by the bicycle dynamics <a href="http://www.control.lth.se/media/Staff/KarlJohanAstrom/Lectures/BikeTalkKTH2006.pdf">paper</a> we encountered in the <a href="http://ieeexplore.ieee.org/Xplore/home.jsp">IEEE database</a>. However, once the controller was implemented, we ran into a few issues:
			<p>First, our controller took into account the derivative of the steering angle, which in <a href="http://www.mathworks.com/products/matlab/">MATLAB</a> were easy to find, but in our actual <a href="http://arduino.cc/">Arduino</a> code, we were forced to use a piece-wise derivative, where we take the difference of the previous values of the steer angle and divide this difference by the loop time of the overall controller.</p>
			<p>Since we elected to put the actual controller code on a timer interrupt, we knew what the exact sampling delay was. We also ran into the issue of the control parameters needing to be re-tuned to take into account the speed at which the front servo is able to move the front wheel. Our <a href="http://www.mathworks.com/products/matlab/">MATLAB</a> model did not include the delay involved in servo movement, so our controller had to be modified so it was even more reactive to the derivative of the lean angle; in this way, the controller would immediately begin to correct, before an appreciable lean angle would develop. Unfortunately, this also made the controller more reactive to disturbances created by the road or pavement that the bike would travel on, as the controller would overreact to even the smallest of ridges or bumps.</p>
			<p>In order to help the bike stay away from walls, we implemented steering in our controller. Originally, we were skeptical this would work at all, as turning requires the controller to be aware of the bicycle's <a href="http://en.wikipedia.org/wiki/Minimum_phase#Non-minimum_phase">non-minimum phase</a> dynamic characteristics. We even attempted to include turning into our <a href="http://www.mathworks.com/products/matlab/">MATLAB</a> simulation of the bicycle in order to test whether or not it was even possible. These turning simulations, which usually had turning as a desired lean angle that the controller would try to match, usually ended with extreme instability in the plant, so we were doubtful turning would work on the actual apparatus. However, in the end, we implemented turning into our control algorithm by fooling the controller into thinking that it was at a different lean angle than it actually was. Essentially, we took the user-input lean angle for the bike (driven by the host <a href="http://en.wikipedia.org/wiki/Personal_computer">PC</a>), and simply added it to the lean angle value that we obtained from our <a href="http://en.wikipedia.org/wiki/Inertial_measurement_unit">IMU</a>. We then fed this new pseudo-lean angle into the controller, and let everything else run as normal. Interestingly enough, this approach worked on the prototype bicycle! Although we have not attempted to command very quick turns, the bicycle is still stable during the turns that we sent it, enough to help it avoid the walls in the hallways when testing. It was even able to make a 90&deg; turn to the left at the end of the corridor and continue onwards (in a trial run whose video unfortunately was corrupted).</p>
			<figure>
				<img src="bike/controller.png">
			</figure>
			<h2>Demonstrations</h2>
			<p><strong>Successful Run:</strong> The bike ran across the entire length of the corridor of <a href="http://en.wikipedia.org/wiki/Etcheverry_Hall">Etcheverry Hall</a> with vague heading inputs given by the user through a laptop to keep it away from the walls and then execute a 90&deg; turn at the end of the corridor. The bike moved at a velocity of around 2 ft/s.</p>
			<figure>
				<iframe width="560" height="315" src="//www.youtube.com/embed/HoL0pjuPYT0" frameborder="0" allowfullscreen></iframe>
			</figure>
			<p><strong>Open Loop Run:</strong> The bike was run with the controller switched off and on a tether at the same velocity as the successful run.</p>
			<figure>
				<iframe width="560" height="315" src="//www.youtube.com/embed/Ka2HltT5Fzg" frameborder="0" allowfullscreen></iframe>
			</figure>
			<p><strong>Failed Runs:</strong> A few of many failed runs while tuning the control algorithm, in order of increasing success.</p>
			<figure>
				<iframe width="560" height="315" src="//www.youtube.com/embed/VMc_ZHx3j6E" frameborder="0" allowfullscreen></iframe>
			</figure>
			<figure>
				<iframe src="https://docs.google.com/file/d/0B5Q5dlAX7nvscHlZazdGVTlLcWM/preview" width="560" height="315"></iframe>
			</figure>
			<figure>
				<iframe src="https://docs.google.com/file/d/0B5Q5dlAX7nvsNWhTTzg2OXprcDA/preview" width="560" height="315"></iframe>
			</figure>
			<h2>Challenges</h2>
			<p>Throughout the course of the project, the biggest challenges we faced (even including those mentioned in the last section) were the numerous mechanical and low level software faults and failings of our bike. The software problems we encountered were not high level, theoretical things such as problems designing a complicated control algorithms, but small glitches which accumulated throughout the project.</p>
			<p>Before building out this project, we thought that most of our work would be on the control algorithm and software. We believed that most deficiencies in the mechanical design of the bike can be checked through smarter software and controls. Thus, we did not spend too much time and effort on the mechanical design of the bike frame, powertrain and steering actuation. In the long run however, this lack of focus on mechanical detail caused us numerous delays and complications; we had to make frequent runs to the <a href="http://www.me.berkeley.edu/new/Shop/enter.html">machine shop</a> to repair broken parts and fabricate new ones. Mechanical issues that we faced included the frame falling apart, miscalculated tolerances in shafts and pulleys, belt tension and friction in the drive train. Apart from costing us time to come up with solutions to these problems, these problems also complicated our control design. During our tests, we had a hard time of assessing whether a failure was due to flaws in the controls or hardware, making our controller iterations and tuning painfully slow. The controller design and tuning was much simpler and more effective after we took the time to repair and mitigate the numerous, minor, mechanical flaws.</p>
			<h2>Future</h2>
			<p>We gained a lot of experience and learned a new, diverse set of skills throughout this project. We also understood the specifics of the project more intimately than we did during proposal. Although we achieved everything we set out to do, there were things we could have done differently to develop a better system and also have some idea of where we could have taken this project a step further.</p>
			<p>If we were to start this project over again, we believe that the first thing we would change about our approach is our hardware. During testing, we were constantly hampered by failing hardware; this made control parameter tuning fairly difficult, as bicycle instability could originate from either the loose or faulty hardware, or improper tuning. Specifically, we would make the front fork stronger, so that it would not become misaligned or break if the bike hits a wall.</p>
			<p>Furthermore, we would also ensure that the mounting mechanism for the motor and rear wheel assembly were properly machined to the right sizes and tolerances, so that we do not run into issues of pulley misalignment or excessive rear wheel friction.</p>
			<p>The problems that we ran into for wireless communications, however, were mostly out of bad luck. During initial research, we found both <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a> serial communication example code and wireless connectivity drivers online. We did not foresee the version problems that we ended up having to deal with. However, to combat this in a possible version 2, our only argument is to perhaps start earlier on the wireless communication code, giving us enough time to ask around on the internet for help from people who understand device overlays for enabling <a href="http://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">UART</a>.</p>
			<p>To simplify controller for the purposes of our project, we implemented a <a href="http://en.wikipedia.org/wiki/Control_theory#Classical_control_theory">SISO</a> controller. We did so by running the bike at a constant velocity and exploring how slow we could go. However, this required constant tuning of our control parameters according to the bike speed which limited our ability to really test the limits of speed and stability. The sensitivity of our control parameters with respect to bike velocity was evident in our demonstrations. The control gains were tuned to the bike when it was running on a drained battery, but during the demo, the battery was fresh and fully charged. The increased speed in the motor caused the controls to be too reactive, and almost unstable. Thus, in a future version, we would like implement a more complex controller, which consists of two <a href="http://en.wikipedia.org/wiki/Control_theory#Classical_control_theory">SISO</a> control loops running parallel for the lean and velocity control. This would induce a certain speed dependence in the values of the control parameters, but more rigorous testing would be able to provide that information.</p>
			<h2>Code</h2>
			<strong>Arduino:</strong><br>
			<a href="https://github.com/engj/engj.github.io/blob/master/bike/arduino_code/main.ino">main.ino</a><br>
			<strong>BeagleBone:</strong><br>
			<a href="https://github.com/engj/engj.github.io/blob/master/bike/beaglebone_code/server.py">server.py</a><br>
			<a href="https://github.com/engj/engj.github.io/blob/master/bike/beaglebone_code/net_threads.py">net_threads.py</a><br>
			<a href="https://github.com/engj/engj.github.io/blob/master/bike/beaglebone_code/start.sh">start.sh</a><br>
			<strong>Laptop:</strong><br>
			<a href="https://github.com/engj/engj.github.io/blob/master/bike/laptop_code/client.py">client.py</a><br>
			<a href="https://github.com/engj/engj.github.io/blob/master/bike/laptop_code/net_threads.py">net_threads.py</a><br>
			<a href="https://github.com/engj/engj.github.io/blob/master/bike/laptop_code/start.sh">start.sh</a>
 		</article>
	</div>
</body>
</html>